#!/usr/bin/env tern

import solutions.Fetch;

const i = Fetch.iterator(9); 

println(plot(10,i));

func plot(s,i) {
   const r = Rope(s);
   
   while(i.hasNext()) {
      const n = i.next().split(" ");
      const m = Move.resolve(n[0]);
      
      r.move(m, n[1].toInteger());
   }
   return r.s.size;
}

class Rope {
   const k: List<Pos>;
   const s = {};

   new(length) {
      this.k = [].fill(Pos(10 ^ 5, 10 ^ 5), length);
   }
   
   move(m: Move, c: Integer) {
      for(i in 1 to c) {
         let p = (k[0] = k[0].move(m));
         
         for(j in 1 to k.length - 1) {
            const n = k[j].follow(p);
            
            if(n == k[j]) {
               break;
            }
            k[j] = n;
            p = n;
         }
         s.add("${k[k.length-1]}");
      }
   }
}

class Pos {
  const x;
  const y;
  
  new(x, y) {
     this.x = x;
     this.y = y;
  }
  
  move(m: Move) {
     Pos(x + m.x, y + m.y);
  }
  
  follow(p: Pos) {
     const d = dist(p);
     
     if(d > 3) {
       return Pos(x > p.x ? p.x + 1 : p.x- 1, y > p.y ? p.y + 1 : p.y- 1);
     }
     if(d > 1) {
        if(x == p.x || Math.abs(y - p.y) == 2) {
           return Pos(p.x, y > p.y ? p.y + 1 : p.y- 1);
        } 
        if(y == p.y || Math.abs(x - p.x) == 2) {
           return Pos(x > p.x ? p.x + 1 : p.x- 1, p.y);        
        }
     }
     return this; // no move
  }
  
  dist(p: Pos) {
     const x = Math.abs(x - p.x);
     const y = Math.abs(y - p.y);
     
     return x + y;
  }
  
  toString() {
     "${x}, ${y}";
  }
}

enum Move {
   UP(0, -1),
   DOWN(0, 1),
   LEFT(-1, 0),
   RIGHT(1, 0);
   
   const x;
   const y;
   
   new(x, y) {
      this.x = x;
      this.y = y;
   }
   
   static resolve(d) {
      switch(d) {
         case 'U': return UP;
         case 'D': return DOWN;
         case 'L': return LEFT;
         case 'R': return RIGHT;
      }
   }
}